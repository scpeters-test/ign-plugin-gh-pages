{"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75733580.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75733580"}}, "parent": {"id": 75685427, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75685427.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75685427"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "That's a very excellent suggestion \\(I thought I had done that, but you\u2019re right that it wasn\u2019t tested yet\\).\n\nCreating tests for this revealed that there is a surprising fundamental flaw with the approach. It turns out that if you unload the library of a class while the call stack has not yet exited the destructor of that class, then you will get a segmentation fault no matter what. Even if _no more symbols depending on the plugin library_ need to be called, the call stack will simply not know how to exit the plugin class\u2019s destructor \\(which has been unloaded from the program\u2019s memory\\), and will instead experience a segmentation fault.\n\nI\u2019ve revised the approach in [this experimental branch](#!/ignitionrobotics/ign-plugin/branch/Factory_vexing?dest=Factory#diff) which includes a test that currently fails on the branch of this PR. The issue with the revised approach is that to avoid memory leaks, you need to handle a `std::unique_ptr` with a custom deleter, which kind of decimates the usefulness of this feature. You can no longer pass a raw pointer along to be handled by a different memory management system.\n\nI\u2019m going to keep thinking about this issue, but unfortunately I suspect we\u2019ve hit an inherent weakness of plugin-based systems. It\u2019s not surprising that other plugin frameworks like Qt just happily resign themselves to memory leaks.", "markup": "markdown", "html": "<p>That's a very excellent suggestion (I thought I had done that, but you\u2019re right that it wasn\u2019t tested yet).</p>\n<p>Creating tests for this revealed that there is a surprising fundamental flaw with the approach. It turns out that if you unload the library of a class while the call stack has not yet exited the destructor of that class, then you will get a segmentation fault no matter what. Even if <em>no more symbols depending on the plugin library</em> need to be called, the call stack will simply not know how to exit the plugin class\u2019s destructor (which has been unloaded from the program\u2019s memory), and will instead experience a segmentation fault.</p>\n<p>I\u2019ve revised the approach in <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-plugin/branch/Factory_vexing?dest=Factory#diff\" rel=\"nofollow\">this experimental branch</a> which includes a test that currently fails on the branch of this PR. The issue with the revised approach is that to avoid memory leaks, you need to handle a <code>std::unique_ptr</code> with a custom deleter, which kind of decimates the usefulness of this feature. You can no longer pass a raw pointer along to be handled by a different memory management system.</p>\n<p>I\u2019m going to keep thinking about this issue, but unfortunately I suspect we\u2019ve hit an inherent weakness of plugin-based systems. It\u2019s not surprising that other plugin frameworks like Qt just happily resign themselves to memory leaks.</p>", "type": "rendered"}, "created_on": "2018-09-12T10:32:10.388605+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-09-12T10:35:25.766754+00:00", "type": "pullrequest_comment", "id": 75733580}