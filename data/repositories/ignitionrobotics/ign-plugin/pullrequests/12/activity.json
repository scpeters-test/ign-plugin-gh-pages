{"pagelen": 50, "values": [{"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e305aa35f7aa", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e305aa35f7aa.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e305aa35f7aa"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "MERGED", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-14T23:31:30.756823+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"approval": {"date": "2018-09-14T23:30:57.483123+00:00", "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "e305aa35f7aa", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e305aa35f7aa.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e305aa35f7aa"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-14T20:31:15.952533+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4d1382475609", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/4d1382475609.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/4d1382475609"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-14T18:47:11.507996+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "4d1382475609", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/4d1382475609.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/4d1382475609"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-14T18:47:11.349238+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f00f08e5d030", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/f00f08e5d030.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/f00f08e5d030"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-14T18:35:41.702229+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f00f08e5d030", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/f00f08e5d030.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/f00f08e5d030"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-14T18:35:41.449867+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "dd9de65fd224", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/dd9de65fd224.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/dd9de65fd224"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-14T09:22:27.959297+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "62fd6a3d7783", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/62fd6a3d7783.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/62fd6a3d7783"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-14T03:36:52.166612+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "c808c6ee6f2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/c808c6ee6f2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/c808c6ee6f2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-13T09:02:30.868027+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75855985.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75855985"}}, "parent": {"id": 75796194, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75796194.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75796194"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "I\u2019ve pushed some significant changes now with a revised approach to factory product management. It includes tests to show that the methodology is working.\n\nI\u2019d say I\u2019m roughly 95% satisfied with this new approach, and I think it\u2019s valuable enough to be worth merging.\n\nThe remaining 5% of my potential satisfaction might actually require fundamental changes to the way shared libraries work within the operating system, so we may just have to count that as a loss.", "markup": "markdown", "html": "<p>I\u2019ve pushed some significant changes now with a revised approach to factory product management. It includes tests to show that the methodology is working.</p>\n<p>I\u2019d say I\u2019m roughly 95% satisfied with this new approach, and I think it\u2019s valuable enough to be worth merging.</p>\n<p>The remaining 5% of my potential satisfaction might actually require fundamental changes to the way shared libraries work within the operating system, so we may just have to count that as a loss.</p>", "type": "rendered"}, "created_on": "2018-09-13T08:32:55.154378+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-09-13T08:34:10.916196+00:00", "type": "pullrequest_comment", "id": 75855985}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "3f4596ac3bf8", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/3f4596ac3bf8.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/3f4596ac3bf8"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-13T08:30:42.165905+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75796194.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75796194"}}, "parent": {"id": 75733580, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75733580.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75733580"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "well, I'm glad we're aware of the issue now\n\nso is this branch still worth merging?", "markup": "markdown", "html": "<p>well, I'm glad we're aware of the issue now</p>\n<p>so is this branch still worth merging?</p>", "type": "rendered"}, "created_on": "2018-09-12T17:58:16.520833+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-09-12T17:58:16.527115+00:00", "type": "pullrequest_comment", "id": 75796194}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75733580.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75733580"}}, "parent": {"id": 75685427, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75685427.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75685427"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "That's a very excellent suggestion \\(I thought I had done that, but you\u2019re right that it wasn\u2019t tested yet\\).\n\nCreating tests for this revealed that there is a surprising fundamental flaw with the approach. It turns out that if you unload the library of a class while the call stack has not yet exited the destructor of that class, then you will get a segmentation fault no matter what. Even if _no more symbols depending on the plugin library_ need to be called, the call stack will simply not know how to exit the plugin class\u2019s destructor \\(which has been unloaded from the program\u2019s memory\\), and will instead experience a segmentation fault.\n\nI\u2019ve revised the approach in [this experimental branch](#!/ignitionrobotics/ign-plugin/branch/Factory_vexing?dest=Factory#diff) which includes a test that currently fails on the branch of this PR. The issue with the revised approach is that to avoid memory leaks, you need to handle a `std::unique_ptr` with a custom deleter, which kind of decimates the usefulness of this feature. You can no longer pass a raw pointer along to be handled by a different memory management system.\n\nI\u2019m going to keep thinking about this issue, but unfortunately I suspect we\u2019ve hit an inherent weakness of plugin-based systems. It\u2019s not surprising that other plugin frameworks like Qt just happily resign themselves to memory leaks.", "markup": "markdown", "html": "<p>That's a very excellent suggestion (I thought I had done that, but you\u2019re right that it wasn\u2019t tested yet).</p>\n<p>Creating tests for this revealed that there is a surprising fundamental flaw with the approach. It turns out that if you unload the library of a class while the call stack has not yet exited the destructor of that class, then you will get a segmentation fault no matter what. Even if <em>no more symbols depending on the plugin library</em> need to be called, the call stack will simply not know how to exit the plugin class\u2019s destructor (which has been unloaded from the program\u2019s memory), and will instead experience a segmentation fault.</p>\n<p>I\u2019ve revised the approach in <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-plugin/branch/Factory_vexing?dest=Factory#diff\" rel=\"nofollow\">this experimental branch</a> which includes a test that currently fails on the branch of this PR. The issue with the revised approach is that to avoid memory leaks, you need to handle a <code>std::unique_ptr</code> with a custom deleter, which kind of decimates the usefulness of this feature. You can no longer pass a raw pointer along to be handled by a different memory management system.</p>\n<p>I\u2019m going to keep thinking about this issue, but unfortunately I suspect we\u2019ve hit an inherent weakness of plugin-based systems. It\u2019s not surprising that other plugin frameworks like Qt just happily resign themselves to memory leaks.</p>", "type": "rendered"}, "created_on": "2018-09-12T10:32:10.388605+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-09-12T10:35:25.766754+00:00", "type": "pullrequest_comment", "id": 75733580}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75688204.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75688204"}}, "parent": {"id": 75680026, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75680026.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75680026"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "I made this a bit more consistent: 2a62b18", "markup": "markdown", "html": "<p>I made this a bit more consistent: <a href=\"#!/ignitionrobotics/ign-plugin/commits/2a62b18\" rel=\"nofollow\" class=\"ap-connect-link\">2a62b18</a></p>", "type": "rendered"}, "created_on": "2018-09-12T02:32:49.389069+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-09-12T02:32:49.396657+00:00", "type": "pullrequest_comment", "id": 75688204}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "2a62b18a0797", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/2a62b18a0797.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/2a62b18a0797"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-12T02:32:24.895103+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75687888.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75687888"}}, "parent": {"id": 75681541, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75681541.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75681541"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "Whoops, this was supposed to be replaced by `utility_TEST.cc`. Removed: 2c4c6c3", "markup": "markdown", "html": "<p>Whoops, this was supposed to be replaced by <code>utility_TEST.cc</code>. Removed: <a href=\"#!/ignitionrobotics/ign-plugin/commits/2c4c6c3\" rel=\"nofollow\" class=\"ap-connect-link\">2c4c6c3</a></p>", "type": "rendered"}, "created_on": "2018-09-12T02:24:30.889370+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-09-12T02:24:30.901468+00:00", "type": "pullrequest_comment", "id": 75687888}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "2c4c6c3ee2bb", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/2c4c6c3ee2bb.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/2c4c6c3ee2bb"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-12T02:23:38.566704+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75687785.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75687785"}}, "parent": {"id": 75685604, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75685604.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75685604"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "Yeah, when I originally designed the feature, I had intended to make a function called `Loader::Factory(std::string)` that would give the user the ability to call a function `->Construct(Args&&...)`.\n\nIn the process of implementing it, I realized that the most sensible way of implementing this feature would have the side-effect of enabling users to instantiate a `std::shared_ptr<Interface>` to the interface of any kind of plugin, not just factories.\n\nI decided to just roll with it, since it doesn\u2019t really hurt anything, and it might be useful for other cases.\n\nI'd be totally open to renaming the `Loader::Factory` function, but I'd like a name that emphasizes that it's the recommended function for reaching the `Factory<T, Args...>::Construct(Args&&...)` API.", "markup": "markdown", "html": "<p>Yeah, when I originally designed the feature, I had intended to make a function called <code>Loader::Factory(std::string)</code> that would give the user the ability to call a function <code>-&gt;Construct(Args&amp;&amp;...)</code>.</p>\n<p>In the process of implementing it, I realized that the most sensible way of implementing this feature would have the side-effect of enabling users to instantiate a <code>std::shared_ptr&lt;Interface&gt;</code> to the interface of any kind of plugin, not just factories.</p>\n<p>I decided to just roll with it, since it doesn\u2019t really hurt anything, and it might be useful for other cases.</p>\n<p>I'd be totally open to renaming the <code>Loader::Factory</code> function, but I'd like a name that emphasizes that it's the recommended function for reaching the <code>Factory&lt;T, Args...&gt;::Construct(Args&amp;&amp;...)</code> API.</p>", "type": "rendered"}, "created_on": "2018-09-12T02:21:07.503128+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-09-12T02:21:07.509029+00:00", "type": "pullrequest_comment", "id": 75687785}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75685604.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75685604"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "This is a pretty cool feature, but I was confused when I initially read this documentation because I thought this function was only useful as an intermediate step to calling `Construct`, maybe because it's called `Factory`.", "markup": "markdown", "html": "<p>This is a pretty cool feature, but I was confused when I initially read this documentation because I thought this function was only useful as an intermediate step to calling <code>Construct</code>, maybe because it's called <code>Factory</code>.</p>", "type": "rendered"}, "created_on": "2018-09-12T01:20:29.059282+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-09-12T01:20:29.065525+00:00", "type": "pullrequest_comment", "id": 75685604}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75685427.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75685427"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "I think we should add a test that confirms the lifecycle you describe in the pull request description (release pointer returned from `Construct` and confirm that shared library is not unloaded until object is deleted).", "markup": "markdown", "html": "<p>I think we should add a test that confirms the lifecycle you describe in the pull request description (release pointer returned from <code>Construct</code> and confirm that shared library is not unloaded until object is deleted).</p>", "type": "rendered"}, "created_on": "2018-09-12T01:16:17.930902+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-09-12T01:16:17.937282+00:00", "type": "pullrequest_comment", "id": 75685427}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "5a20698d52a2", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/5a20698d52a2.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/5a20698d52a2"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-12T01:00:36.294250+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "adfe7232f565", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/adfe7232f565.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/adfe7232f565"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-12T00:58:52.875556+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "291881db43cc", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/291881db43cc.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/291881db43cc"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-12T00:40:59.928210+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75681541.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75681541"}}, "parent": {"id": 75340363, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75340363.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75340363"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "I agree, this file should be deleted", "markup": "markdown", "html": "<p>I agree, this file should be deleted</p>", "type": "rendered"}, "created_on": "2018-09-11T23:45:36.903574+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-09-11T23:45:36.911318+00:00", "type": "pullrequest_comment", "id": 75681541}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75680026.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75680026"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "`ReturnT` -> `ReturnType`?", "markup": "markdown", "html": "<p><code>ReturnT</code> -&gt; <code>ReturnType</code>?</p>", "type": "rendered"}, "created_on": "2018-09-11T23:16:36.508274+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-09-11T23:16:36.515131+00:00", "type": "pullrequest_comment", "id": 75680026}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "14baea33714a", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/14baea33714a.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/14baea33714a"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-11T02:48:34.118207+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75543937.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75543937"}}, "parent": {"id": 75513286, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75513286.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75513286"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "Changed here: b1e58aa\n\nI also revised `ForgetLibraryOfPlugin(~)` to accept aliases, and I made the documentation style more consistent between the various functions.", "markup": "markdown", "html": "<p>Changed here: <a href=\"#!/ignitionrobotics/ign-plugin/commits/b1e58aa\" rel=\"nofollow\" class=\"ap-connect-link\">b1e58aa</a></p>\n<p>I also revised <code>ForgetLibraryOfPlugin(~)</code> to accept aliases, and I made the documentation style more consistent between the various functions.</p>", "type": "rendered"}, "created_on": "2018-09-11T02:43:47.456825+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {}, "updated_on": "2018-09-11T02:43:47.464422+00:00", "type": "pullrequest_comment", "id": 75543937}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b1e58aa45316", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/b1e58aa45316.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/b1e58aa45316"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-11T02:43:01.087248+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75513286.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75513286"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "`_pluginNameOrAlias`?", "markup": "markdown", "html": "<p><code>_pluginNameOrAlias</code>?</p>", "type": "rendered"}, "created_on": "2018-09-10T18:38:08.045927+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "inline": {}, "updated_on": "2018-09-10T18:38:08.052817+00:00", "type": "pullrequest_comment", "id": 75513286}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "563171601efb", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/563171601efb.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/563171601efb"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-10T18:00:43.568292+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75434709.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75434709"}}, "parent": {"id": 75413941, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75413941.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75413941"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "no, targeting default is just fine", "markup": "markdown", "html": "<p>no, targeting default is just fine</p>", "type": "rendered"}, "created_on": "2018-09-10T09:03:50.104866+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-09-10T09:03:50.111970+00:00", "type": "pullrequest_comment", "id": 75434709}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75421476.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75421476"}}, "parent": {"id": 75404589, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75404589.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75404589"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "Jenkins job for Windows passed as well: [https://build.osrfoundation.org/job/ignition\\_plugin-ci-pr\\_any-windows7-amd64/53/](https://build.osrfoundation.org/job/ignition_plugin-ci-pr_any-windows7-amd64/53)\n\n~~I\u2019m not sure what caused the current \u201cfailure\u201d status, but it looks like it\u2019s a `java.nio.channels.ClosedChannelException` which might be related to wiline?~~ A more recent Jenkins job [has passed](https://build.osrfoundation.org/job/ignition_plugin-ci-pr_any-windows7-amd64/56/), so I think we can ignore the failure.", "markup": "markdown", "html": "<p>Jenkins job for Windows passed as well: <a data-is-external-link=\"true\" href=\"https://build.osrfoundation.org/job/ignition_plugin-ci-pr_any-windows7-amd64/53\" rel=\"nofollow\">https://build.osrfoundation.org/job/ignition_plugin-ci-pr_any-windows7-amd64/53/</a></p>\n<p><del>I\u2019m not sure what caused the current \u201cfailure\u201d status, but it looks like it\u2019s a <code>java.nio.channels.ClosedChannelException</code> which might be related to wiline?</del> A more recent Jenkins job <a data-is-external-link=\"true\" href=\"https://build.osrfoundation.org/job/ignition_plugin-ci-pr_any-windows7-amd64/56/\" rel=\"nofollow\">has passed</a>, so I think we can ignore the failure.</p>", "type": "rendered"}, "created_on": "2018-09-10T07:34:57.829851+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-09-10T08:16:38.251186+00:00", "type": "pullrequest_comment", "id": 75421476}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75413941.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75413941"}}, "parent": {"id": 75412281, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75412281.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75412281"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "I\u2019ve created a small PR for this: [#!/ignitionrobotics/ign-plugin/pull-requests/14/](#!/ignitionrobotics/ign-plugin/pull-requests/14/)\n\nIf you'd prefer, I can target that PR at this branch instead of `default`.", "markup": "markdown", "html": "<p>I\u2019ve created a small PR for this: <a data-is-external-link=\"true\" href=\"#!/ignitionrobotics/ign-plugin/pull-requests/14/\" rel=\"nofollow\">#!/ignitionrobotics/ign-plugin/pull-requests/14/</a></p>\n<p>If you'd prefer, I can target that PR at this branch instead of <code>default</code>.</p>", "type": "rendered"}, "created_on": "2018-09-10T06:23:52.309604+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-09-10T06:23:52.316785+00:00", "type": "pullrequest_comment", "id": 75413941}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75413365.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75413365"}}, "parent": {"id": 75412281, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75412281.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75412281"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "We can fix it here or I can pop open a small PR to fix it.", "markup": "markdown", "html": "<p>We can fix it here or I can pop open a small PR to fix it.</p>", "type": "rendered"}, "created_on": "2018-09-10T06:16:23.718306+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-09-10T06:16:23.725411+00:00", "type": "pullrequest_comment", "id": 75413365}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75412281.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75412281"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "I just noticed some inconsistent variable names in pull request #11, but it has already been merged. Should we fix it here?\n\n* #!/ignitionrobotics/ign-plugin/pull-requests/11/plugin-enhancements-part-2-aliases/diff#comment-75412209", "markup": "markdown", "html": "<p>I just noticed some inconsistent variable names in <a href=\"#!/ignitionrobotics/ign-plugin/pull-requests/11/plugin-enhancements-part-2-aliases\" rel=\"nofollow\" class=\"ap-connect-link\">pull request #11</a>, but it has already been merged. Should we fix it here?</p>\n<ul>\n<li><a href=\"#!/ignitionrobotics/ign-plugin/pull-requests/11/plugin-enhancements-part-2-aliases/diff#comment-75412209\" rel=\"nofollow\" class=\"ap-connect-link\">#!/ignitionrobotics/ign-plugin/pull-requests/11/plugin-enhancements-part-2-aliases/diff#comment-75412209</a></li>\n</ul>", "type": "rendered"}, "created_on": "2018-09-10T05:59:29.214134+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2018-09-10T05:59:29.221487+00:00", "type": "pullrequest_comment", "id": 75412281}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75406235.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75406235"}}, "parent": {"id": 75404757, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75404757.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75404757"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "This seemed to suppress the false flag on my machine: 035d99f", "markup": "markdown", "html": "<p>This seemed to suppress the false flag on my machine: <a href=\"#!/ignitionrobotics/ign-plugin/commits/035d99f\" rel=\"nofollow\" class=\"ap-connect-link\">035d99f</a></p>", "type": "rendered"}, "created_on": "2018-09-10T03:34:43.209437+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-09-10T03:34:43.217115+00:00", "type": "pullrequest_comment", "id": 75406235}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "aea69ab3ed14", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/aea69ab3ed14.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/aea69ab3ed14"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "035d99f849a8", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/035d99f849a8.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/035d99f849a8"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-10T03:34:16.247150+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "aea69ab3ed14", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/aea69ab3ed14.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/aea69ab3ed14"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b20d1b5a6306", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/b20d1b5a6306.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/b20d1b5a6306"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-10T03:27:06.625977+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "aea69ab3ed14", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/aea69ab3ed14.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/aea69ab3ed14"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b20d1b5a6306", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/b20d1b5a6306.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/b20d1b5a6306"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-10T03:27:06.589484+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75404757.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75404757"}}, "parent": {"id": 75343188, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75343188.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75343188"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "Also the \u201csyntax error\u201d seems to be code check saying that it doesn\u2019t know how to parse the syntax; I don\u2019t think it\u2019s saying that there\u2019s an actual error there \\(\u2026 at least it shouldn\u2019t be saying there\u2019s an error, because there definitely isn\u2019t an error\\).  The codecheck target is still returning with success, regardless of that printout, so I recommend we just ignore it \\(unless there\u2019s a way to suppress this type of output\\).", "markup": "markdown", "html": "<p>Also the \u201csyntax error\u201d seems to be code check saying that it doesn\u2019t know how to parse the syntax; I don\u2019t think it\u2019s saying that there\u2019s an actual error there (\u2026 at least it shouldn\u2019t be saying there\u2019s an error, because there definitely isn\u2019t an error).  The codecheck target is still returning with success, regardless of that printout, so I recommend we just ignore it (unless there\u2019s a way to suppress this type of output).</p>", "type": "rendered"}, "created_on": "2018-09-10T02:45:34.878869+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-09-10T02:45:34.886086+00:00", "type": "pullrequest_comment", "id": 75404757}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75404589.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75404589"}}, "parent": {"id": 75343188, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75343188.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75343188"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "It seems that Ubuntu and Windows are slightly different in how they demangle the symbol name of a class that was instantiated from a template.\n\nThe test assumes that spaces will be placed between the template arguments so that\u2019s what I told the test to expect. But Windows \\(which is what failed here\\) does not put spaces between the template arguments within a symbol, so the lookup failed.\n\nI made the test more robust here: b77d1f6 Now it will search for key components of the symbol name and choose the plugin name that contains those components instead of assuming a specific precise name.\n\nWindows is happy now: [https://ci.appveyor.com/project/scpeters/ign-plugin/build/1.0.31](https://ci.appveyor.com/project/scpeters/ign-plugin/build/1.0.31)\n\n\\(I started a new Jenkins job for Windows, but the Jenkins server doesn\u2019t seem to be responding.\\)", "markup": "markdown", "html": "<p>It seems that Ubuntu and Windows are slightly different in how they demangle the symbol name of a class that was instantiated from a template.</p>\n<p>The test assumes that spaces will be placed between the template arguments so that\u2019s what I told the test to expect. But Windows (which is what failed here) does not put spaces between the template arguments within a symbol, so the lookup failed.</p>\n<p>I made the test more robust here: <a href=\"#!/ignitionrobotics/ign-plugin/commits/b77d1f6\" rel=\"nofollow\" class=\"ap-connect-link\">b77d1f6</a> Now it will search for key components of the symbol name and choose the plugin name that contains those components instead of assuming a specific precise name.</p>\n<p>Windows is happy now: <a data-is-external-link=\"true\" href=\"https://ci.appveyor.com/project/scpeters/ign-plugin/build/1.0.31\" rel=\"nofollow\">https://ci.appveyor.com/project/scpeters/ign-plugin/build/1.0.31</a></p>\n<p>(I started a new Jenkins job for Windows, but the Jenkins server doesn\u2019t seem to be responding.)</p>", "type": "rendered"}, "created_on": "2018-09-10T02:39:34.998557+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-09-10T02:40:04.728160+00:00", "type": "pullrequest_comment", "id": 75404589}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "934f70e86e07", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/934f70e86e07.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/934f70e86e07"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "b20d1b5a6306", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/b20d1b5a6306.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/b20d1b5a6306"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-10T02:15:39.759383+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "934f70e86e07", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/934f70e86e07.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/934f70e86e07"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "22d58d8ffac4", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/22d58d8ffac4.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/22d58d8ffac4"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-07T20:50:30.964545+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75343188.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75343188"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "Code check is returning syntax errors:\n\n\\[core/include/ignition/plugin/detail/Factory.hh:31\\]: \\(error\\) syntax error\n\n\u200c\n\nThe factory integration test failed on ubuntu: [https://build.osrfoundation.org/view/sw\\_ignition/job/ignition\\_plugin-ci-pr\\_any-windows7-amd64/52/consoleFull#45593342ed30c675-ba23-4c35-b655-f5c948f97581](https://build.osrfoundation.org/view/sw_ignition/job/ignition_plugin-ci-pr_any-windows7-amd64/52/consoleFull#45593342ed30c675-ba23-4c35-b655-f5c948f97581)", "markup": "markdown", "html": "<p>Code check is returning syntax errors:</p>\n<p>[core/include/ignition/plugin/detail/Factory.hh:31]: (error) syntax error</p>\n<p>\u200c</p>\n<p>The factory integration test failed on ubuntu: <a data-is-external-link=\"true\" href=\"https://build.osrfoundation.org/view/sw_ignition/job/ignition_plugin-ci-pr_any-windows7-amd64/52/consoleFull#45593342ed30c675-ba23-4c35-b655-f5c948f97581\" rel=\"nofollow\">https://build.osrfoundation.org/view/sw_ignition/job/ignition_plugin-ci-pr_any-windows7-amd64/52/consoleFull#45593342ed30c675-ba23-4c35-b655-f5c948f97581</a></p>", "type": "rendered"}, "created_on": "2018-09-07T15:05:15.571496+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-09-07T15:05:15.577799+00:00", "type": "pullrequest_comment", "id": 75343188}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "934f70e86e07", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/934f70e86e07.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/934f70e86e07"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "246002942075", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/246002942075.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/246002942075"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2018-09-07T14:49:03.399689+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75340363.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75340363"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "Is this file needed?", "markup": "markdown", "html": "<p>Is this file needed?</p>", "type": "rendered"}, "created_on": "2018-09-07T14:44:47.193856+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "inline": {}, "updated_on": "2018-09-07T14:44:47.202479+00:00", "type": "pullrequest_comment", "id": 75340363}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "ef8744cfe6f3", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/ef8744cfe6f3.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/ef8744cfe6f3"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "cbbffc0617d7", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/cbbffc0617d7.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/cbbffc0617d7"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "date": "2018-09-07T14:29:10.602464+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "1c48d4bb12ae", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/1c48d4bb12ae.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/1c48d4bb12ae"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "f8bcad3def1a", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/f8bcad3def1a.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/f8bcad3def1a"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "date": "2018-09-07T05:28:22.816494+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "060a24f66f2e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/060a24f66f2e.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/060a24f66f2e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "2f5234149dd0", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/2f5234149dd0.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/2f5234149dd0"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-06T08:49:42.918547+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}], "next": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/activity_ctx=qkujsrUo.json"}