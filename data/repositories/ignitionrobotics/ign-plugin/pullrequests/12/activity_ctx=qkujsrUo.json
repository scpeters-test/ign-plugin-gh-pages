{"pagelen": 50, "values": [{"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "060a24f66f2e", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/060a24f66f2e.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/060a24f66f2e"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "ae8edf8b4fc8", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/ae8edf8b4fc8.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/ae8edf8b4fc8"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-06T08:27:13.275902+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75127365.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75127365"}}, "parent": {"id": 75097662, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75097662.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75097662"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "Yep, as of this PR, we'll have all the features we've ever thought of for `ign-plugin`.", "markup": "markdown", "html": "<p>Yep, as of this PR, we'll have all the features we've ever thought of for <code>ign-plugin</code>.</p>", "type": "rendered"}, "created_on": "2018-09-06T03:16:39.839846+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-09-06T03:16:39.849618+00:00", "type": "pullrequest_comment", "id": 75127365}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"comment": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments/75097662.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12/_/diff#comment-75097662"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}, "content": {"raw": "@mxgrey We are getting close to feature freeze and code freeze for SubT. Are you okay with making this the last PR to ign-plugins until October? ", "markup": "markdown", "html": "<p>@mxgrey We are getting close to feature freeze and code freeze for SubT. Are you okay with making this the last PR to ign-plugins until October? </p>", "type": "rendered"}, "created_on": "2018-09-05T18:49:24.769724+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": "2018-09-05T18:49:24.782750+00:00", "type": "pullrequest_comment", "id": 75097662}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "c7ded5960661", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/c7ded5960661.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/c7ded5960661"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "be935663992c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/be935663992c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/be935663992c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-04T10:20:33.255536+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "9f57dd59689f", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/9f57dd59689f.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/9f57dd59689f"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "d380d2033652", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/d380d2033652.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/d380d2033652"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-04T09:59:14.873108+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n      \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "9f57dd59689f", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/9f57dd59689f.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/9f57dd59689f"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "d380d2033652", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/d380d2033652.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/d380d2033652"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-04T09:57:50.761862+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}, {"update": {"description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n      \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "title": "Plugin Enhancements Part 3: Factory", "destination": {"commit": {"hash": "9f57dd59689f", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/9f57dd59689f.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/9f57dd59689f"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "reason": "", "source": {"commit": {"hash": "d380d2033652", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/d380d2033652.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/d380d2033652"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "state": "OPEN", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "date": "2018-09-04T09:57:50.702633+00:00"}, "pull_request": {"type": "pullrequest", "id": 12, "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}}, "title": "Plugin Enhancements Part 3: Factory"}}]}