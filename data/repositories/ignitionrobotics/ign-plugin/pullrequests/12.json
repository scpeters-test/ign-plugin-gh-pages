{"rendered": {"description": {"raw": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "markup": "markdown", "html": "<p>This PR is the last in the line of the new enhancements to plugins.</p>\n<p>A common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a <code>QWidget</code> plugin, you need to pass a raw pointer of that <code>QWidget</code> off to a native <code>Qt</code> parent object which will then manage its lifecycle.</p>\n<p>This creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in <code>ign-gui</code> by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.</p>\n<p>In this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments (or no arguments at all) and produces a <code>std::unique_ptr&lt;Interface&gt;</code> where <code>Interface</code> is the interface you want to give to the plugin consumer. In the case of <code>Qt</code>, you can <code>.release()</code> this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that <code>Interface</code> object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.</p>\n<p>I\u2019ll use <code>ign-gui</code> as an example of how the factory can be used:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// file: ignition/gui/Plugin.hh</span>\n\n<span class=\"err\">#</span><span class=\"nx\">ifndef</span> <span class=\"nx\">IGNITION_GUI_PLUGIN_HH_</span>\n<span class=\"err\">#</span><span class=\"nx\">define</span> <span class=\"nx\">IGNITION_GUI_PLUGIN_HH_</span>\n\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">QWidget</span><span class=\"o\">&gt;</span>\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">ignition</span><span class=\"o\">/</span><span class=\"nx\">plugin</span><span class=\"o\">/</span><span class=\"nx\">Factory</span><span class=\"p\">.</span><span class=\"nx\">hh</span><span class=\"o\">&gt;</span>\n\n<span class=\"nx\">namespace</span> <span class=\"nx\">ignition</span> <span class=\"p\">{</span>\n<span class=\"nx\">namespace</span> <span class=\"nx\">gui</span> <span class=\"p\">{</span>\n\n<span class=\"kr\">class</span> <span class=\"nx\">IGNITION_GUI_VISIBLE</span> <span class=\"nx\">Plugin</span> : <span class=\"kt\">public</span> <span class=\"nx\">QWidget</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// virtual member functions</span>\n  <span class=\"c1\">// member variables</span>\n  <span class=\"c1\">// etc</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// Define a factory that takes no inputs and produces a</span>\n<span class=\"c1\">// std::unique_ptr&lt;Plugin&gt;</span>\n<span class=\"nx\">using</span> <span class=\"nx\">WidgetFactory</span> <span class=\"o\">=</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">plugin</span><span class=\"o\">::</span><span class=\"nx\">Factory</span><span class=\"o\">&lt;</span><span class=\"nx\">Plugin</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"err\">#</span><span class=\"nx\">endif</span>\n</pre></div>\n\n\n<p>\u200c</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// file: user/src/plugin.cc</span>\n\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">ignition</span><span class=\"o\">/</span><span class=\"nx\">gui</span><span class=\"o\">/</span><span class=\"nx\">Plugin</span><span class=\"p\">.</span><span class=\"nx\">hh</span><span class=\"o\">&gt;</span>\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">ignition</span><span class=\"o\">/</span><span class=\"nx\">plugin</span><span class=\"o\">/</span><span class=\"nx\">Register</span><span class=\"p\">.</span><span class=\"nx\">hh</span><span class=\"o\">&gt;</span>\n\n<span class=\"kr\">class</span> <span class=\"nx\">MyGuiWidget</span> : <span class=\"kt\">public</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">gui</span><span class=\"o\">::</span><span class=\"nx\">Plugin</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// implement virtual functions</span>\n  <span class=\"c1\">// declare member variables</span>\n  <span class=\"c1\">// etc</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">IGNITION_ADD_FACTORY</span><span class=\"p\">(</span><span class=\"nx\">MyGuiWidget</span><span class=\"p\">,</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">gui</span><span class=\"o\">::</span><span class=\"nx\">WidgetFactory</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>And then you would retrieve the user's <code>MyGuiWidget</code> plugin by doing the following:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nt\">ignition</span><span class=\"p\">::</span><span class=\"nd\">plugin</span><span class=\"p\">::</span><span class=\"nd\">Loader</span> <span class=\"nt\">loader</span><span class=\"o\">;</span>\n<span class=\"nt\">loader</span><span class=\"p\">.</span><span class=\"nc\">LoadLibrary</span><span class=\"o\">(</span><span class=\"s2\">&quot;/path/to/user/library&quot;</span><span class=\"o\">);</span>\n\n<span class=\"nt\">std</span><span class=\"p\">::</span><span class=\"nd\">unique_ptr</span><span class=\"o\">&lt;</span><span class=\"nt\">ignition</span><span class=\"p\">::</span><span class=\"nd\">gui</span><span class=\"p\">::</span><span class=\"nd\">Plugin</span><span class=\"o\">&gt;</span> <span class=\"nt\">plugin</span> <span class=\"o\">=</span>\n    <span class=\"nt\">loader</span><span class=\"p\">.</span><span class=\"nc\">Factory</span><span class=\"o\">(</span><span class=\"s2\">&quot;MyGuiWidget&quot;</span><span class=\"o\">)</span><span class=\"nt\">-</span><span class=\"o\">&gt;</span><span class=\"nt\">Construct</span><span class=\"o\">();</span>\n\n<span class=\"o\">//</span> <span class=\"nt\">Now</span> <span class=\"nt\">you</span> <span class=\"nt\">can</span> <span class=\"nt\">safely</span> <span class=\"nt\">pass</span> <span class=\"nt\">the</span> <span class=\"nt\">widget</span> <span class=\"nt\">off</span> <span class=\"nt\">to</span> <span class=\"nt\">its</span> <span class=\"nt\">parent</span> <span class=\"nt\">by</span> <span class=\"nt\">calling</span>\n<span class=\"o\">//</span> <span class=\"nt\">plugin</span><span class=\"p\">.</span><span class=\"nc\">release</span><span class=\"o\">().</span> <span class=\"nt\">You</span> <span class=\"nt\">do</span> <span class=\"nt\">not</span> <span class=\"nt\">need</span> <span class=\"nt\">to</span> <span class=\"nt\">manage</span> <span class=\"nt\">its</span> <span class=\"nt\">reference</span> <span class=\"nt\">count</span> <span class=\"nt\">from</span>\n<span class=\"o\">//</span> <span class=\"nt\">here</span> <span class=\"nt\">on</span> <span class=\"nt\">out</span><span class=\"o\">.</span>\n</pre></div>\n\n\n<p>\u200c</p>\n<p>Note that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base <a data-is-external-link=\"true\" href=\"http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget\" rel=\"nofollow\">QWidget</a> class (I'm not saying this is a good idea, I'm just offering a hypothetical):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">//</span> <span class=\"nt\">file</span><span class=\"o\">:</span> <span class=\"nt\">ignition</span><span class=\"o\">/</span><span class=\"nt\">gui</span><span class=\"o\">/</span><span class=\"nt\">Plugin</span><span class=\"p\">.</span><span class=\"nc\">hh</span>\n\n<span class=\"c\">/* class Plugin definition goes here */</span>\n\n<span class=\"nt\">using</span> <span class=\"nt\">WidgetFactory</span> <span class=\"o\">=</span> <span class=\"nt\">ignition</span><span class=\"p\">::</span><span class=\"nd\">plugin</span><span class=\"p\">::</span><span class=\"nd\">Factory</span><span class=\"o\">&lt;</span><span class=\"nt\">Plugin</span><span class=\"o\">,</span> <span class=\"nt\">QWidget</span><span class=\"o\">*,</span> <span class=\"nt\">Qt</span><span class=\"p\">::</span><span class=\"nd\">WindowFlags</span><span class=\"o\">&gt;;</span>\n</pre></div>\n\n\n<p>\u200c</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// file: user/src/plugin.cc</span>\n\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">ignition</span><span class=\"o\">/</span><span class=\"nx\">gui</span><span class=\"o\">/</span><span class=\"nx\">Plugin</span><span class=\"p\">.</span><span class=\"nx\">hh</span><span class=\"o\">&gt;</span>\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">ignition</span><span class=\"o\">/</span><span class=\"nx\">plugin</span><span class=\"o\">/</span><span class=\"nx\">Register</span><span class=\"p\">.</span><span class=\"nx\">hh</span><span class=\"o\">&gt;</span>\n\n<span class=\"kr\">class</span> <span class=\"nx\">MyGuiWidget</span> : <span class=\"kt\">public</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">gui</span><span class=\"o\">::</span><span class=\"nx\">Plugin</span>\n<span class=\"p\">{</span>\n  <span class=\"kr\">public</span><span class=\"o\">:</span> <span class=\"nx\">MyGuiWidget</span><span class=\"p\">(</span><span class=\"nx\">QWidget</span><span class=\"o\">*</span> <span class=\"nx\">parent</span><span class=\"p\">,</span> <span class=\"nx\">Qt</span><span class=\"o\">::</span><span class=\"nx\">WindowFlags</span> <span class=\"nx\">f</span><span class=\"p\">);</span>\n\n  <span class=\"c1\">// implement virtual functions</span>\n  <span class=\"c1\">// declare member variables</span>\n  <span class=\"c1\">// etc</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">IGNITION_ADD_FACTORY</span><span class=\"p\">(</span><span class=\"nx\">MyGuiWidget</span><span class=\"p\">,</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">gui</span><span class=\"o\">::</span><span class=\"nx\">WidgetFactory</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>And then you would construct it like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nt\">ignition</span><span class=\"p\">::</span><span class=\"nd\">plugin</span><span class=\"p\">::</span><span class=\"nd\">Loader</span> <span class=\"nt\">loader</span><span class=\"o\">;</span>\n<span class=\"nt\">loader</span><span class=\"p\">.</span><span class=\"nc\">LoadLibrary</span><span class=\"o\">(</span><span class=\"s2\">&quot;/path/to/user/library&quot;</span><span class=\"o\">);</span>\n\n<span class=\"nt\">QWidget</span><span class=\"o\">*</span> <span class=\"nt\">parent</span> <span class=\"o\">=</span> <span class=\"nt\">getParent</span><span class=\"o\">();</span>\n<span class=\"nt\">Qt</span><span class=\"p\">::</span><span class=\"nd\">WindowFlags</span> <span class=\"nt\">flags</span> <span class=\"o\">=</span> <span class=\"nt\">getFlags</span><span class=\"o\">();</span>\n\n<span class=\"nt\">std</span><span class=\"p\">::</span><span class=\"nd\">unique_ptr</span><span class=\"o\">&lt;</span><span class=\"nt\">ignition</span><span class=\"p\">::</span><span class=\"nd\">gui</span><span class=\"p\">::</span><span class=\"nd\">Plugin</span><span class=\"o\">&gt;</span> <span class=\"nt\">plugin</span> <span class=\"o\">=</span>\n    <span class=\"nt\">loader</span><span class=\"p\">.</span><span class=\"nc\">Factory</span><span class=\"o\">(</span><span class=\"s2\">&quot;MyGuiWidget&quot;</span><span class=\"o\">)</span><span class=\"nt\">-</span><span class=\"o\">&gt;</span><span class=\"nt\">Construct</span><span class=\"o\">(</span><span class=\"nt\">parent</span><span class=\"o\">,</span> <span class=\"nt\">flags</span><span class=\"o\">);</span>\n</pre></div>", "type": "rendered"}, "title": {"raw": "Plugin Enhancements Part 3: Factory", "markup": "markdown", "html": "<p>Plugin Enhancements Part 3: Factory</p>", "type": "rendered"}}, "type": "pullrequest", "description": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-plugin/pullrequests/12/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-plugin/diffstat/ignitionrobotics/ign-plugin:a766208b616d%0De743be809b2c?from_pullrequest_id=12"}, "commits": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/commits.json"}, "self": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12.json"}, "comments": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-plugin/pullrequests/12/merge"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/pull-requests/12"}, "activity": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-plugin/diff/ignitionrobotics/ign-plugin:a766208b616d%0De743be809b2c?from_pullrequest_id=12"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/ignitionrobotics/ign-plugin/pullrequests/12/approve"}, "statuses": {"href": "data/repositories/ignitionrobotics/ign-plugin/pullrequests/12/statuses_page=1.json"}}, "title": "Plugin Enhancements Part 3: Factory", "close_source_branch": true, "reviewers": [], "id": 12, "destination": {"commit": {"hash": "e743be809b2c", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e743be809b2c.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e743be809b2c"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "default"}}, "created_on": "2018-09-04T09:57:50.670586+00:00", "summary": {"raw": "This PR is the last in the line of the new enhancements to plugins.\r\n\r\nA common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a `QWidget` plugin, you need to pass a raw pointer of that `QWidget` off to a native `Qt` parent object which will then manage its lifecycle.\r\n\r\nThis creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in `ign-gui` by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.\r\n\r\nIn this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments \\(or no arguments at all\\) and produces a `std::unique_ptr<Interface>` where `Interface` is the interface you want to give to the plugin consumer. In the case of `Qt`, you can `.release()` this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that `Interface` object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.\r\n\r\nI\u2019ll use `ign-gui` as an example of how the factory can be used:\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    #ifndef IGNITION_GUI_PLUGIN_HH_\r\n    #define IGNITION_GUI_PLUGIN_HH_\r\n    \r\n    #include <QWidget>\r\n    #include <ignition/plugin/Factory.hh>\r\n    \r\n    namespace ignition {\r\n    namespace gui {\r\n    \r\n    class IGNITION_GUI_VISIBLE Plugin : public QWidget\r\n    {\r\n      // virtual member functions\r\n      // member variables\r\n      // etc\r\n    };\r\n    \r\n    // Define a factory that takes no inputs and produces a\r\n    // std::unique_ptr<Plugin>\r\n    using WidgetFactory = ignition::plugin::Factory<Plugin>;\r\n    \r\n    }\r\n    }\r\n    \r\n    #endif\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would retrieve the user's `MyGuiWidget` plugin by doing the following:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct();\r\n    \r\n    // Now you can safely pass the widget off to its parent by calling\r\n    // plugin.release(). You do not need to manage its reference count from\r\n    // here on out.\r\n\r\n\u200c\r\n\r\nNote that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base [QWidget](http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget) class \\(I'm not saying this is a good idea, I'm just offering a hypothetical\\):\r\n\r\n    // file: ignition/gui/Plugin.hh\r\n    \r\n    /* class Plugin definition goes here */\r\n    \r\n    using WidgetFactory = ignition::plugin::Factory<Plugin, QWidget*, Qt::WindowFlags>;\r\n\r\n\u200c\r\n\r\n    // file: user/src/plugin.cc\r\n    \r\n    #include <ignition/gui/Plugin.hh>\r\n    #include <ignition/plugin/Register.hh>\r\n    \r\n    class MyGuiWidget : public ignition::gui::Plugin\r\n    {\r\n      public: MyGuiWidget(QWidget* parent, Qt::WindowFlags f);\r\n    \r\n      // implement virtual functions\r\n      // declare member variables\r\n      // etc\r\n    };\r\n    \r\n    IGNITION_ADD_FACTORY(MyGuiWidget, ignition::gui::WidgetFactory)\r\n\r\nAnd then you would construct it like this:\r\n\r\n    ignition::plugin::Loader loader;\r\n    loader.LoadLibrary(\"/path/to/user/library\");\r\n    \r\n    QWidget* parent = getParent();\r\n    Qt::WindowFlags flags = getFlags();\r\n    \r\n    std::unique_ptr<ignition::gui::Plugin> plugin =\r\n        loader.Factory(\"MyGuiWidget\")->Construct(parent, flags);", "markup": "markdown", "html": "<p>This PR is the last in the line of the new enhancements to plugins.</p>\n<p>A common requirement for plugin classes is that it needs to be possible to hand off ownership of the object that has been imported from the external library. For example, if you want to have a <code>QWidget</code> plugin, you need to pass a raw pointer of that <code>QWidget</code> off to a native <code>Qt</code> parent object which will then manage its lifecycle.</p>\n<p>This creates some friction with our plugin framework, because we need to track the usage of each shared library to make sure that we don't unload a library while one of its symbols is still in use. @chapulina dodged this in <code>ign-gui</code> by manually keeping a reference-count to the original plugin alive, and then manually deleting the widgets before that reference count gets wiped out.</p>\n<p>In this PR, we fix this problem entirely using a \"Factory\" paradigm. Now you can define a plugin Factory which takes in some number of arguments (or no arguments at all) and produces a <code>std::unique_ptr&lt;Interface&gt;</code> where <code>Interface</code> is the interface you want to give to the plugin consumer. In the case of <code>Qt</code>, you can <code>.release()</code> this pointer and hand it off to a parent widget, which will manage its lifecycle. As long as that <code>Interface</code> object is alive, the plugin framework will keep its library loaded, so there is no need to manually hold onto a reference count or to manually delete objects.</p>\n<p>I\u2019ll use <code>ign-gui</code> as an example of how the factory can be used:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// file: ignition/gui/Plugin.hh</span>\n\n<span class=\"err\">#</span><span class=\"nx\">ifndef</span> <span class=\"nx\">IGNITION_GUI_PLUGIN_HH_</span>\n<span class=\"err\">#</span><span class=\"nx\">define</span> <span class=\"nx\">IGNITION_GUI_PLUGIN_HH_</span>\n\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">QWidget</span><span class=\"o\">&gt;</span>\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">ignition</span><span class=\"o\">/</span><span class=\"nx\">plugin</span><span class=\"o\">/</span><span class=\"nx\">Factory</span><span class=\"p\">.</span><span class=\"nx\">hh</span><span class=\"o\">&gt;</span>\n\n<span class=\"nx\">namespace</span> <span class=\"nx\">ignition</span> <span class=\"p\">{</span>\n<span class=\"nx\">namespace</span> <span class=\"nx\">gui</span> <span class=\"p\">{</span>\n\n<span class=\"kr\">class</span> <span class=\"nx\">IGNITION_GUI_VISIBLE</span> <span class=\"nx\">Plugin</span> : <span class=\"kt\">public</span> <span class=\"nx\">QWidget</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// virtual member functions</span>\n  <span class=\"c1\">// member variables</span>\n  <span class=\"c1\">// etc</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// Define a factory that takes no inputs and produces a</span>\n<span class=\"c1\">// std::unique_ptr&lt;Plugin&gt;</span>\n<span class=\"nx\">using</span> <span class=\"nx\">WidgetFactory</span> <span class=\"o\">=</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">plugin</span><span class=\"o\">::</span><span class=\"nx\">Factory</span><span class=\"o\">&lt;</span><span class=\"nx\">Plugin</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"err\">#</span><span class=\"nx\">endif</span>\n</pre></div>\n\n\n<p>\u200c</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// file: user/src/plugin.cc</span>\n\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">ignition</span><span class=\"o\">/</span><span class=\"nx\">gui</span><span class=\"o\">/</span><span class=\"nx\">Plugin</span><span class=\"p\">.</span><span class=\"nx\">hh</span><span class=\"o\">&gt;</span>\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">ignition</span><span class=\"o\">/</span><span class=\"nx\">plugin</span><span class=\"o\">/</span><span class=\"nx\">Register</span><span class=\"p\">.</span><span class=\"nx\">hh</span><span class=\"o\">&gt;</span>\n\n<span class=\"kr\">class</span> <span class=\"nx\">MyGuiWidget</span> : <span class=\"kt\">public</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">gui</span><span class=\"o\">::</span><span class=\"nx\">Plugin</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// implement virtual functions</span>\n  <span class=\"c1\">// declare member variables</span>\n  <span class=\"c1\">// etc</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">IGNITION_ADD_FACTORY</span><span class=\"p\">(</span><span class=\"nx\">MyGuiWidget</span><span class=\"p\">,</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">gui</span><span class=\"o\">::</span><span class=\"nx\">WidgetFactory</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>And then you would retrieve the user's <code>MyGuiWidget</code> plugin by doing the following:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nt\">ignition</span><span class=\"p\">::</span><span class=\"nd\">plugin</span><span class=\"p\">::</span><span class=\"nd\">Loader</span> <span class=\"nt\">loader</span><span class=\"o\">;</span>\n<span class=\"nt\">loader</span><span class=\"p\">.</span><span class=\"nc\">LoadLibrary</span><span class=\"o\">(</span><span class=\"s2\">&quot;/path/to/user/library&quot;</span><span class=\"o\">);</span>\n\n<span class=\"nt\">std</span><span class=\"p\">::</span><span class=\"nd\">unique_ptr</span><span class=\"o\">&lt;</span><span class=\"nt\">ignition</span><span class=\"p\">::</span><span class=\"nd\">gui</span><span class=\"p\">::</span><span class=\"nd\">Plugin</span><span class=\"o\">&gt;</span> <span class=\"nt\">plugin</span> <span class=\"o\">=</span>\n    <span class=\"nt\">loader</span><span class=\"p\">.</span><span class=\"nc\">Factory</span><span class=\"o\">(</span><span class=\"s2\">&quot;MyGuiWidget&quot;</span><span class=\"o\">)</span><span class=\"nt\">-</span><span class=\"o\">&gt;</span><span class=\"nt\">Construct</span><span class=\"o\">();</span>\n\n<span class=\"o\">//</span> <span class=\"nt\">Now</span> <span class=\"nt\">you</span> <span class=\"nt\">can</span> <span class=\"nt\">safely</span> <span class=\"nt\">pass</span> <span class=\"nt\">the</span> <span class=\"nt\">widget</span> <span class=\"nt\">off</span> <span class=\"nt\">to</span> <span class=\"nt\">its</span> <span class=\"nt\">parent</span> <span class=\"nt\">by</span> <span class=\"nt\">calling</span>\n<span class=\"o\">//</span> <span class=\"nt\">plugin</span><span class=\"p\">.</span><span class=\"nc\">release</span><span class=\"o\">().</span> <span class=\"nt\">You</span> <span class=\"nt\">do</span> <span class=\"nt\">not</span> <span class=\"nt\">need</span> <span class=\"nt\">to</span> <span class=\"nt\">manage</span> <span class=\"nt\">its</span> <span class=\"nt\">reference</span> <span class=\"nt\">count</span> <span class=\"nt\">from</span>\n<span class=\"o\">//</span> <span class=\"nt\">here</span> <span class=\"nt\">on</span> <span class=\"nt\">out</span><span class=\"o\">.</span>\n</pre></div>\n\n\n<p>\u200c</p>\n<p>Note that we can also make factories that accept arguments to pass to the constructor of the plugin object. For example, if we wanted the plugin object constructors to accept the same arguments as the base <a data-is-external-link=\"true\" href=\"http://doc.qt.io/archives/qt-4.8/qwidget.html#QWidget\" rel=\"nofollow\">QWidget</a> class (I'm not saying this is a good idea, I'm just offering a hypothetical):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">//</span> <span class=\"nt\">file</span><span class=\"o\">:</span> <span class=\"nt\">ignition</span><span class=\"o\">/</span><span class=\"nt\">gui</span><span class=\"o\">/</span><span class=\"nt\">Plugin</span><span class=\"p\">.</span><span class=\"nc\">hh</span>\n\n<span class=\"c\">/* class Plugin definition goes here */</span>\n\n<span class=\"nt\">using</span> <span class=\"nt\">WidgetFactory</span> <span class=\"o\">=</span> <span class=\"nt\">ignition</span><span class=\"p\">::</span><span class=\"nd\">plugin</span><span class=\"p\">::</span><span class=\"nd\">Factory</span><span class=\"o\">&lt;</span><span class=\"nt\">Plugin</span><span class=\"o\">,</span> <span class=\"nt\">QWidget</span><span class=\"o\">*,</span> <span class=\"nt\">Qt</span><span class=\"p\">::</span><span class=\"nd\">WindowFlags</span><span class=\"o\">&gt;;</span>\n</pre></div>\n\n\n<p>\u200c</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// file: user/src/plugin.cc</span>\n\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">ignition</span><span class=\"o\">/</span><span class=\"nx\">gui</span><span class=\"o\">/</span><span class=\"nx\">Plugin</span><span class=\"p\">.</span><span class=\"nx\">hh</span><span class=\"o\">&gt;</span>\n<span class=\"err\">#</span><span class=\"nx\">include</span> <span class=\"o\">&lt;</span><span class=\"nx\">ignition</span><span class=\"o\">/</span><span class=\"nx\">plugin</span><span class=\"o\">/</span><span class=\"nx\">Register</span><span class=\"p\">.</span><span class=\"nx\">hh</span><span class=\"o\">&gt;</span>\n\n<span class=\"kr\">class</span> <span class=\"nx\">MyGuiWidget</span> : <span class=\"kt\">public</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">gui</span><span class=\"o\">::</span><span class=\"nx\">Plugin</span>\n<span class=\"p\">{</span>\n  <span class=\"kr\">public</span><span class=\"o\">:</span> <span class=\"nx\">MyGuiWidget</span><span class=\"p\">(</span><span class=\"nx\">QWidget</span><span class=\"o\">*</span> <span class=\"nx\">parent</span><span class=\"p\">,</span> <span class=\"nx\">Qt</span><span class=\"o\">::</span><span class=\"nx\">WindowFlags</span> <span class=\"nx\">f</span><span class=\"p\">);</span>\n\n  <span class=\"c1\">// implement virtual functions</span>\n  <span class=\"c1\">// declare member variables</span>\n  <span class=\"c1\">// etc</span>\n<span class=\"p\">};</span>\n\n<span class=\"nx\">IGNITION_ADD_FACTORY</span><span class=\"p\">(</span><span class=\"nx\">MyGuiWidget</span><span class=\"p\">,</span> <span class=\"nx\">ignition</span><span class=\"o\">::</span><span class=\"nx\">gui</span><span class=\"o\">::</span><span class=\"nx\">WidgetFactory</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>And then you would construct it like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nt\">ignition</span><span class=\"p\">::</span><span class=\"nd\">plugin</span><span class=\"p\">::</span><span class=\"nd\">Loader</span> <span class=\"nt\">loader</span><span class=\"o\">;</span>\n<span class=\"nt\">loader</span><span class=\"p\">.</span><span class=\"nc\">LoadLibrary</span><span class=\"o\">(</span><span class=\"s2\">&quot;/path/to/user/library&quot;</span><span class=\"o\">);</span>\n\n<span class=\"nt\">QWidget</span><span class=\"o\">*</span> <span class=\"nt\">parent</span> <span class=\"o\">=</span> <span class=\"nt\">getParent</span><span class=\"o\">();</span>\n<span class=\"nt\">Qt</span><span class=\"p\">::</span><span class=\"nd\">WindowFlags</span> <span class=\"nt\">flags</span> <span class=\"o\">=</span> <span class=\"nt\">getFlags</span><span class=\"o\">();</span>\n\n<span class=\"nt\">std</span><span class=\"p\">::</span><span class=\"nd\">unique_ptr</span><span class=\"o\">&lt;</span><span class=\"nt\">ignition</span><span class=\"p\">::</span><span class=\"nd\">gui</span><span class=\"p\">::</span><span class=\"nd\">Plugin</span><span class=\"o\">&gt;</span> <span class=\"nt\">plugin</span> <span class=\"o\">=</span>\n    <span class=\"nt\">loader</span><span class=\"p\">.</span><span class=\"nc\">Factory</span><span class=\"o\">(</span><span class=\"s2\">&quot;MyGuiWidget&quot;</span><span class=\"o\">)</span><span class=\"nt\">-</span><span class=\"o\">&gt;</span><span class=\"nt\">Construct</span><span class=\"o\">(</span><span class=\"nt\">parent</span><span class=\"o\">,</span> <span class=\"nt\">flags</span><span class=\"o\">);</span>\n</pre></div>", "type": "rendered"}, "source": {"commit": {"hash": "e305aa35f7aa", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/e305aa35f7aa.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/e305aa35f7aa"}}}, "repository": {"links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin"}, "avatar": {"href": "data/bytebucket.org/ravatar/{f4e3de89-d527-44d3-b10f-fde17d644890}ts=c_plus_plus"}}, "type": "repository", "name": "ign-plugin", "full_name": "ignitionrobotics/ign-plugin", "uuid": "{f4e3de89-d527-44d3-b10f-fde17d644890}"}, "branch": {"name": "Factory"}}, "comment_count": 24, "state": "MERGED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2018-09-14T23:30:57.483123+00:00", "type": "participant", "approved": true, "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}}, {"role": "PARTICIPANT", "participated_on": "2018-09-07T15:05:15.577799+00:00", "type": "participant", "approved": false, "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}, {"role": "PARTICIPANT", "participated_on": "2018-09-13T08:34:10.916196+00:00", "type": "participant", "approved": false, "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}}], "reason": "", "updated_on": "2018-09-14T23:31:30.746617+00:00", "author": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "merge_commit": {"hash": "a766208b616d", "type": "commit", "links": {"self": {"href": "data/repositories/ignitionrobotics/ign-plugin/commit/a766208b616d.json"}, "html": {"href": "#!/ignitionrobotics/ign-plugin/commits/a766208b616d"}}}, "closed_by": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}}